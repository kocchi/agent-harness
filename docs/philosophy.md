# 設計原理（Philosophy）

agent-harness の設計原理を解説します。

## P1: コンテキスト競合の排除

**要点**: 役割分離された複数サブエージェントの同時稼働を前提とする

AI活用が進むほど、単一エージェントの巨大コンテキストは破綻しやすくなります。
よって、役割ごとにサブエージェントを分離し、コンテキストを侵食し合わない構造で品質と速度を上げます。

**ルール**:
- 単一エージェントに全文脈を詰め込まない
- 役割ごとにサブエージェントを分離する
- サブエージェント間は成果物（中間生成物）で受け渡す
- 並列稼働を前提とし、主コンテキストを侵食しない

**アンチパターン**:
- 一つのプロンプトに全情報を詰め込む
- エージェントの役割が曖昧なまま進める

## P2: 中間生成物で合意を運ぶ

**要点**: 契約・失敗モード・テスト戦略で「意図と根拠」を検査可能にする

Righting Software の考え方を踏襲し、コードレビューだけでなく、中間生成物で意図と根拠を検査可能にします。
曖昧→抽象合意→具体化→実装、という往復運動を成果物で管理します。

**中間生成物**:
- **契約**: API/イベント/データの入出力仕様
- **失敗モード**: 何が壊れうるか、その影響と対策
- **テスト戦略**: 何が証明書になるか、どのレベルで検証するか
- **計測設計**: 成功/失敗を何で判定するか

**ルール**:
- コードの前に中間生成物を作成する
- レビューはコードだけでなく中間生成物も対象とする
- 意図と根拠を検査可能な形で残す

## P3: 道具を減らす

**要点**: 各スライスで「減らせる道具」を必ず評価する

リアーキテクチャは段階移行を基本とし、各スライスごとに「減らせる道具／消せる構成」を評価します。
統合すべきか分割すべきかの判断も、エージェントが検査・提案できるようにします。

**削除の条件**:
- 削除対象が明確である
- 代替経路が証明されている（新経路のテストが通っている）
- ロールバックがある（フラグ/段階展開/互換性）
- 影響範囲が見えている（契約と依存が書かれている）

## P4: 知識は資産

**要点**: ルール/スキル/ナレッジとして蓄積し、以後の作業に自動適用する

環境構築の暗黙知、結合の作法、チーム固有の留意点などは、都度チャットで消費せず、ルール／スキル／ナレッジとして蓄積し、以後の作業に自動適用される仕組みにします。

**知識の種類**:
- **ルール**: 常に適用される制約や作法（例: コミットメッセージの形式）
- **スキル**: 特定の作業を行う手順や知識（例: 環境構築手順）
- **ナレッジ**: 参照用の情報や過去の学習（例: 失敗事例）

**ルール**:
- 知見はチャットで消費せず、ルール/スキル/ナレッジとして蓄積する
- 蓄積した知識は以後の作業に自動適用される
- SSoTに集約し、ダブルメンテを禁止する

## 組織固有の原理

P5 以降は組織固有の原理として `_config/org/` で定義できます。
例: モバイル領域の統合、セキュリティポリシー、コンプライアンス要件など
